#!/usr/bin/env bash
# Rofi extension for BitWarden-cli
NAME="$(basename "$0")"
VERSION="0.4"
DEFAULT_CLEAR=5
BW_HASH=

# Options
CLEAR=$DEFAULT_CLEAR # Clear password after N seconds (0 to disable)
SHOW_PASSWORD=no # Show part of the password in the notification
AUTO_LOCK=900 # 15 minutes, default for bitwarden apps

# Holds the available items in memory
ITEMS=

# Stores which command will be used to emulate keyboard type
AUTOTYPE_MODE=

# Stores which command will be used to deal with clipboards
CLIPBOARD_MODE=wayland

# Specify what happens when pressing Enter on an item.
# Defaults to copy_password, can be changed to (auto_type all) or (auto_type password) or show_item_actions
ENTER_CMD=${ENTER_CMD:=copy_password}

# Keyboard shortcuts
KB_SYNC="Alt+r"
KB_URLSEARCH="Alt+u"
KB_NAMESEARCH="Alt+n"
KB_FOLDERSELECT="Alt+c"
KB_TOTPCOPY="Alt+t"
KB_LOCK="Alt+L"
KB_TYPEALL="Alt+1"
KB_TYPEUSER="Alt+2"
KB_TYPEPASS="Alt+3"

# Item type classification
TYPE_LOGIN=1
TYPE_NOTE=2
TYPE_CARD=3
TYPE_IDENTITY=4

# Populated in parse_cli_arguments
ROFI_OPTIONS=()
DEDUP_MARK="(+)"

# Source helper functions
DIR="$(dirname "$(readlink -f "$0")")"
source "$DIR/lib-bwmenu"

ask_password() {
  mpw=$(printf '' | rofi -dmenu -p "Master Password" -password -lines 0) || exit $?
  echo "$mpw" | bw unlock 2>/dev/null | grep 'export' | sed -E 's/.*export BW_SESSION="(.*==)"$/\1/' || display_then_exit $? "Could not unlock vault"
}

get_session_key() {
  if [ $AUTO_LOCK -eq 0 ]; then
    keyctl purge user bw_session &>/dev/null
    BW_HASH=$(ask_password)
  else
    if ! key_id=$(keyctl request user bw_session 2>/dev/null); then
      session=$(ask_password)
      [[ -z "$session" ]] && display_then_exit 1 "Could not unlock vault"
      key_id=$(echo "$session" | keyctl padd user bw_session @u)
    fi

    if [ $AUTO_LOCK -gt 0 ]; then
      keyctl timeout "$key_id" $AUTO_LOCK
    fi
    BW_HASH=$(keyctl pipe "$key_id")
  fi
}

# source the hash file to gain access to the BitWarden CLI
# Pre fetch all the items
load_items() {
  if ! ITEMS=$(bw list items --session "$BW_HASH" 2>/dev/null); then
    display_then_exit $? "Could not load items"
  fi
}

display_then_exit() {
  local code="$1"
  local message="$2"

  rofi -e "$message"
  exit "$code"
}

# Show the Rofi menu with options
# Reads items from stdin
rofi_menu() {

  actions=(
    -kb-custom-1 $KB_SYNC
    -kb-custom-2 $KB_NAMESEARCH
    -kb-custom-3 $KB_URLSEARCH
    -kb-custom-4 $KB_FOLDERSELECT
    -kb-custom-8 $KB_TOTPCOPY
    -kb-custom-9 $KB_LOCK
  )

  msg="<b>$KB_SYNC</b>: sync | <b>$KB_URLSEARCH</b>: urls | <b>$KB_NAMESEARCH</b>: names | <b>$KB_FOLDERSELECT</b>: folders | <b>$KB_TOTPCOPY</b>: totp | <b>$KB_LOCK</b>: lock"

  [[ ! -z "$AUTOTYPE_MODE" ]] && {
    actions+=(
      -kb-custom-5 $KB_TYPEALL
      -kb-custom-6 $KB_TYPEUSER
      -kb-custom-7 $KB_TYPEPASS
    )
    msg+="
<b>$KB_TYPEALL</b>: Type all  | <b>$KB_TYPEUSER</b>: Type user | <b>$KB_TYPEPASS</b>: Type pass"
  }

  rofi -dmenu -p 'Name' \
    -i -no-custom \
    -mesg "$msg" \
    "${actions[@]}" \
    "${ROFI_OPTIONS[@]}"
}

# Show items in a rofi menu by name of the item
show_items() {
  if item=$(
    echo "$ITEMS" \
    | jq -r ".[] | select( has( \"login\" ) ) | \"\\(.name)\"" \
    | dedup_lines \
    | rofi_menu
  ); then
    item_array="$(array_from_name "$item")"
    "${ENTER_CMD[@]}" "$item_array"
  else
    rofi_exit_code=$?
    item_array="$(array_from_name "$item")"
    on_rofi_exit "$rofi_exit_code" "$item_array"
  fi
}

# Similar to show_items() but using the item's ID for deduplication
show_full_items() {
  if item=$(
    echo "$ITEMS" \
    | jq -r ".[] | select( has( \"login\" )) | \"\\(.id): name: \\(.name), username: \\(.login.username)\"" \
    | rofi_menu
  ); then
    item_id="$(echo "$item" | cut -d ':' -f 1)"
    item_array="$(array_from_id "$item_id")"
    "${ENTER_CMD[@]}" "$item_array"
  else
    rofi_exit_code=$?
    item_id="$(echo "$item" | cut -d ':' -f 1)"
    item_array="$(array_from_id "$item_id")"
    on_rofi_exit "$rofi_exit_code" "$item_array"
  fi
}

# Show items in a rofi menu by url of the item
# if url occurs in multiple items, show the menu again with those items only
show_urls() {
  if url=$(
    echo "$ITEMS" \
    | jq -r '.[] | select(has("login")) | .login | select(has("uris")).uris | .[].uri' \
    | rofi_menu
  ); then
    item_array="$(bw list items --url "$url" --session "$BW_HASH")"
    "${ENTER_CMD[@]}" "$item_array"
  else
    rofi_exit_code="$?"
    item_array="$(bw list items --url "$url" --session "$BW_HASH")"
    on_rofi_exit "$rofi_exit_code" "$item_array"
  fi
}

show_folders() {
  folders=$(bw list folders --session "$BW_HASH")
  if folder=$(echo "$folders" | jq -r '.[] | .name' | rofi_menu); then

    folder_id=$(echo "$folders" | jq -r ".[] | select(.name == \"$folder\").id")

    ITEMS=$(bw list items --folderid "$folder_id" --session "$BW_HASH")
    show_items
  else
    rofi_exit_code="$?"
    folder_id=$(echo "$folders" | jq -r ".[] | select(.name == \"$folder\").id")
    item_array=$(bw list items --folderid "$folder_id" --session "$BW_HASH")
    on_rofi_exit "$rofi_exit_code" "$item_array"
  fi
}

# re-sync the BitWarden items with the server
sync_bitwarden() {
  bw sync --session "$BW_HASH" &>/dev/null || display_then_exit 1 "Failed to sync bitwarden"

  load_items
  show_items
}

# Evaluate the rofi exit codes
on_rofi_exit() {
  case "$1" in
    10) sync_bitwarden;;
    11) load_items; show_items;;
    12) show_urls;;
    13) show_folders;;
    17) copy_totp "$2";;
    18) lock_vault;;
    14) auto_type all "$2";;
    15) auto_type username "$2";;
    16) auto_type password "$2";;
    *) exit "$1";;
  esac
}

# Auto type using xdotool/ydotool
# $1: what to type; all, username, password
# $2: item array
auto_type() {
  if not_unique "$2"; then
    ITEMS="$2"
    show_full_items
  else
    sleep 0.3
    case "$1" in
      all)
        type_word "$(echo "$2" | jq -r '.[0].login.username')"
        type_tab
        type_word "$(echo "$2" | jq -r '.[0].login.password')"
        ;;
      username)
        type_word "$(echo "$2" | jq -r '.[0].login.username')"
        ;;
      password)
        type_word "$(echo "$2" | jq -r '.[0].login.password')"
        ;;
    esac
  fi

}

# Set $AUTOTYPE_MODE to a command that will emulate keyboard input
select_autotype_command() {
  if [[ -z "$AUTOTYPE_MODE" ]]; then
    if [ "$XDG_SESSION_TYPE" = "wayland" ] && hash ydotool 2>/dev/null; then
      AUTOTYPE_MODE=(sudo ydotool)
    elif [ "$XDG_SESSION_TYPE" != "wayland" ] && hash xdotool 2>/dev/null; then
      AUTOTYPE_MODE=xdotool
    fi
  fi
}

type_word() {
  "${AUTOTYPE_MODE[@]}" type "$1"
}

type_tab() {
  "${AUTOTYPE_MODE[@]}" key Tab
}


# Set $CLIPBOARD_MODE to a command that will put stdin into the clipboard.
select_copy_command() {
  if [[ -z "$CLIPBOARD_MODE" ]]; then
    if [ "$XDG_SESSION_TYPE" = "wayland" ]; then
      hash wl-copy 2>/dev/null && CLIPBOARD_MODE=wayland
    elif hash xclip 2>/dev/null; then
      CLIPBOARD_MODE=xclip
    elif hash xsel 2>/dev/null; then
      CLIPBOARD_MODE=xsel
    elif hash wl-copy 2>/dev/null; then
      CLIPBOARD_MODE=wayland
    else
      display_then_exit 1 "No clipboard command found. Please install either xclip, xsel, or wl-clipboard."
    fi
    [ -z "$CLIPBOARD_MODE" ] && display_then_exit 1 "No clipboard command found. Please install either xclip, xsel, or wl-clipboard."
  fi
}

clipboard-set() {
  clipboard-${CLIPBOARD_MODE}-set
}

clipboard-set-primary() {
  clipboard-${CLIPBOARD_MODE}-set-primary
}

clipboard-get() {
  clipboard-${CLIPBOARD_MODE}-get
}

clipboard-get-primary() {
  clipboard-${CLIPBOARD_MODE}-get-primary
}

clipboard-clear() {
  clipboard-${CLIPBOARD_MODE}-clear
}

clipboard-clear-primary() {
  clipboard-${CLIPBOARD_MODE}-clear-primary
}

clipboard-xclip-set() {
    xclip -selection clipboard -r
}

clipboard-xclip-set-primary() {
    xclip -selection primary -r
}

clipboard-xclip-get() {
    xclip -selection clipboard -o
}

clipboard-xclip-get-primary() {
    xclip -selection primary -o
}

clipboard-xclip-clear() {
    echo -n "" | xclip -selection clipboard -r
}

clipboard-xclip-clear-primary() {
    echo -n "" | xclip -selection primary -r
}

clipboard-xsel-set() {
  xsel --clipboard --input
}

clipboard-xsel-set-primary() {
  xsel --clipboard --input --primary
}

clipboard-xsel-get() {
  xsel --clipboard
}

clipboard-xsel-get-primary() {
  xsel --primary
}

clipboard-xsel-clear() {
  xsel --clipboard --delete
}

clipboard-xsel-clear-primary() {
  xsel --primary --delete
}

clipboard-wayland-set() {
  wl-copy
}

clipboard-wayland-set-primary() {
  wl-copy --primary
}

clipboard-wayland-get() {
  wl-paste
}

clipboard-wayland-get-primary() {
  wl-paste --primary
}

clipboard-wayland-clear() {
  wl-copy --clear
}

clipboard-wayland-clear-primary() {
  wl-copy --clear --primary
}

show_item_actions() {
  if not_unique "$1"; then
    ITEMS="$1"
    show_full_items
  else
    actions="$(actions_for_item "$1")"
    if selection="$(cut -d : -f 1 <<< "$actions" | select_action)"; then
      selected_action="$(sed "$(( $selection + 1 ))q;d" <<< "$actions")"
      eval "$(cut -d : -f 3- <<< "$selected_action")"
      show_copy_notification "$(cut -d : -f 2 <<< "$selected_action")"
    fi
  fi
}

actions_for_item() {
  actions=()
  if username="$(jq -re ".[0].login.username" <<< "$1")"; then
    actions+=("Copy username:Username copied to clipboard:copy_and_clear clipboard ${username@Q}")
  fi
  if password="$(jq -re ".[0].login.password" <<< "$1")"; then
    actions+=("Copy password:Password copied to clipboard:copy_and_clear clipboard ${password@Q}")
  fi
  if [ -n "$password" ] && [ -n "$username" ] ; then
    actions+=("Copy username and password:Username copied to primary selection<br>Password copied to clipboard: \
                    copy_and_clear primary ${username@Q} \
                 && copy_and_clear clipboard ${password@Q}")
  fi
  if uri="$(jq -re 'map(.login.uris[0].uri | select(. != null)) | first' <<< "$1")" ; then
    actions+=("Open URI::xdg-open ${uri@Q}")
    if [ -n "$password" ] && [ -n "$username" ] ; then
      actions+=("Copy username and password, open URI:Username copied to clipboard<br>Password copied to primary selection: \
                    copy_and_clear clipboard ${username@Q} \
                 && copy_and_clear primary ${password@Q} \
                 && xdg-open ${uri@Q}")
    elif [ -n "$password" ] ; then
      actions+=("Copy password, open URI:Password copied to clipboard:copy_and_clear ${password@Q} && xdg-open ${uri@Q}")
    fi
  fi
  if jq -e '.[0].login.totp' > /dev/null <<< "$1" ; then
    actions+=("Copy TOTP:TOTP copied to clipboard:_copy_totp ${1@Q}")
  fi
  declare -a "custom_field_actions=($(jq -re '.[0].fields | map("Copy " + .name + ":" + .name + " copied to clipboard:copy_and_clear " + (.value | @sh)) | @sh' <<< "$1"))"
  for action in "${custom_field_actions[@]}" ; do
    actions+=("$action")
  done
  if notes="$(jq -re '.[0].notes' <<< "$1")" ; then
    actions+=("Display notes::display_then_exit 0 ${notes@Q}")
  fi
  actions+=("Display everything::_show_everything ${1@Q}")
  printf '%s\n' "${actions[@]}"
}

select_action() {
  rofi -dmenu -p "Action" "$1" -format i -i -no-custom "${ROFI_OPTIONS[@]}"
}

# Copy the password
# copy to clipboard and give the user feedback that the password is copied
# $1: json array of items
copy_password() {
  if not_unique "$1"; then
    ITEMS="$1"
    show_full_items
  else
    pass="$(echo "$1" | jq -r '.[0].login.password')"

    show_copy_notification "$(echo "$1" | jq -r '.[0]')"
    copy_and_clear clipboard "$pass"
  fi
}

_copy_totp() {
  id=$(echo "$1" | jq -r ".[0].id")

  if ! totp=$(bw --session "$BW_HASH" get totp "$id"); then
    display_then_exit 1 "$totp"
  fi

  copy_and_clear clipboard "$totp"
}

# Copy the TOTP
# $1: item array
copy_totp() {
  if not_unique "$1"; then
    ITEMS="$item_array"
    show_full_items
  else
    _copy_totp "$1"
    notify-send "TOTP Copied"
  fi
}

copy_and_clear() {
  if [ "$1" = "primary" ]; then
    clipboard-set-primary <<< "$2"
    if [[ $CLEAR -gt 0 ]]; then
      (
        sleep "$CLEAR"
        if [[ "$(clipboard-get-primary)" == "$2" ]]; then
          clipboard-clear-primary
        fi
      ) &
    fi
  else
    clipboard-set <<< "$2"
    if [[ $CLEAR -gt 0 ]]; then
      (
        sleep "$CLEAR"
        if [[ "$(clipboard-get)" == "$2" ]]; then
          clipboard-clear
        fi
      ) &
    fi
  fi
}

_show_everything() {
  display_then_exit 0 "$(
    jq -re '.[0] |
      .URIs = (.login.uris | map(.uri)) |
      .Username = .login.username |
      .Password = .login.password |
      reduce .fields[] as $field (.; .[$field.name] = $field.value) |
      del(.id, .folderId, .object, .revisionDate, .type, .favorite, .login, .fields) |
      reduce (tostream | select(length==2)) as $i ({}; .[[$i[0][] | tostring] | join(" ")] = $i[1]) |
      to_entries |
      map(if (.value | length) > 0 then .key + ": " + .value else empty end) |
      join("\n")
    ' <<< "$1"
  )"
}

show_copy_notification() {
  # not sure if icon will be present everywhere, /usr/share/icons is default icon location
  notify-send "$1" -i /usr/share/icons/hicolor/64x64/apps/bitwarden.png
}

# Lock the vault by purging the key used to store the session hash
lock_vault() {
  keyctl purge user bw_session &>/dev/null
}

parse_cli_arguments() {
  # Use GNU getopt to parse command line arguments
  if ! ARGUMENTS=$(getopt -o c:C --long auto-lock:,clear:,no-clear,show-password,state-path:,help,version -- "$@"); then
    display_then_exit 1 "Failed to parse command-line arguments"
  fi
  eval set -- "$ARGUMENTS"

  while true; do
    case "$1" in
      --help )
        cat <<-USAGE
$NAME $VERSION

Usage:
  $NAME [options] -- [rofi options]

Options:
  --help
      Show this help text and exit.

  --version
      Show version information and exit.

  --auto-lock <SECONDS>
      Automatically lock the Vault <SECONDS> seconds after last unlock.
      Use 0 to lock immediatly.
      Use -1 to disable.
      Default: 900 (15 minutes)

  -c <SECONDS>, --clear <SECONDS>, --clear=<SECONDS>
      Clear password from clipboard after this many seconds.
      Defaults: ${DEFAULT_CLEAR} seconds.

  -C, --no-clear
      Don't automatically clear the password from the clipboard. This disables
      the default --clear option.

  --show-password
      Show the first 4 characters of the copied password in the notification.

Quick Actions:
  When hovering over an item in the rofi menu, you can make use of Quick Actions.

  $KB_SYNC  Resync your vault

  $KB_URLSEARCH  Search through urls
  $KB_NAMESEARCH  Search through names
  $KB_FOLDERSELECT  Search through folders

  $KB_TOTPCOPY  Copy the TOTP
  $KB_TYPEALL  Autotype the username and password [needs xdotool or ydotool]
  $KB_TYPEUSER  Autotype the username [needs xdotool or ydotool]
  $KB_TYPEPASS  Autotype the password [needs xdotool or ydotool]

  $KB_LOCK  Lock your vault

Examples:
  # Default options work well
  $NAME

  # Immediatly lock the Vault after use
  $NAME --auto-lock 0

  # Never lock the Vault
  $NAME --auto-lock -1

  # Place rofi on top of screen, like a Quake console
  $NAME -- -location 2
USAGE
        shift
        exit 0
        ;;
      --version )
        echo "$NAME $VERSION"
        shift
        exit 0
        ;;
      --auto-lock )
        AUTO_LOCK=$2
        shift 2
        ;;
      -c | --clear )
        CLEAR="$2"
        shift 2
        ;;
      -C | --no-clear )
        CLEAR=0
        shift
        ;;
      --show-password )
        SHOW_PASSWORD=yes
        shift
        ;;
      -- )
        shift
        ROFI_OPTIONS=("$@")
        break
        ;;
      * )
        display_then_exit 1 "Unknown option $1"
    esac
  done
}

parse_cli_arguments "$@"

get_session_key
select_autotype_command
select_copy_command
load_items
show_items
